5/3:
abstract-owtd
1hr planning

players = {
	"excalo": {
		color: "red"
	}
}

nodes = [
	// static
	id: id,
	x: x,
	y: y,

	// dynamic
	owner: "excalo",
	bubbles: 100,
	edges: [
		{
            to: id,
            bubbles: [
                owner: "asdf",
                pos: x,
                dead: false
            ]
        }
	]
]

//bubbles = [
//	//dynamic
//	owner: "excalo",
//	edge: {from: id, to: id}
//	dist: 135
//]

forEachBubble = players.forEach(player=>player.bases.forEach(base=>))

get edges from node: O(1)
get edges to node: O(V)
get nodes in a given area: O(V) -- or better quadtree
get all nodes of a player: O(V)
get all players in an area (by nodes): see above
get bubbles on a given edge: get specific edge O(1) + get bubbles on edge O(bubbles)

bubble update loop: O(B)
1. check for on-edge collisions
	is there an opposing edge? O(1)
	is there a bubble on that edge? O(1)
	what will this bubble's new position be?
	for each bubble
		what will their new position be?
		did this delta t overlap the original delta t?
			kill both
2. check for node collisions (kill bubble, either add or subtract from node)
3. move bubbles
	use the values computed from step 1 above, now that colliding bubbles have been removed
4. spawn new bubbles? (when?)

1000 players
1000 players * 100 nodes each
1000 players * 100 nodes each * 3 edges per node
1000 players * 100 nodes each * 3 edges per node * 5 bubbles per edge
1000 * 100 * 3 * 5 = 1.5M
O(1.5M^2) bubble update

how many 'live' bubbles (on edges) does a player have?
nodes.map(node=>node.edges).map(edge=>edge.bubbles).length (or something like that, maybe with a mapreduce instead)

algorithmic complexity ✓
object pooling ✓
delta compression ✓
ease-of-use ✓

main algorith challenges to define:
- server side bubble update loop
	- collision detection
	- how node radius effects node-bubble collision
- client side bubble update loop (with collision detection)


optimizations to postpone:
- delta compression
- spatial data structures
- cacheing/memoization

5/4: more specific planning for abstract-owtd

bubble update loop: O(B)
1. pre-move, and on-edge collision checking
	calculate and cache this bubbles future position
	is there an opposing edge? O(1)
		is there a bubble on that edge? O(1)
			for each bubble
				calculate and cache this bubbles future position
				did this delta overlap the original delta?
					kill both
2. check for node collisions (kill bubble, either add or subtract from node)
3. move bubbles
	use the values computed from step 1 above, now that colliding bubbles have been removed
4. spawn new bubbles? (when?)
	move to outside of spawning node radius
	check for collision on spawn?

client side bubble render:
- get delta time since last real update
- interpolate bubble position
- check collisions of all kinds

collisions always happen between furthest nodes on opposing edges

enforce a grid by:
all edge distances are in increments according to the move speed of bubbles
- if a bubble moves 10px/sec, edges are always divisible by 10
- radii increase/decrease in increments of 10 only

ALL collisions now only happen exactly during game loop ticks...woah sick
just interpolate the position and you're good to go
wait no

given bubble radius r
every tick, bubble move by r
every 4 ticks (or more, must be even), bubbles spawn
4 ticks per second
bubble move speed = 4r/sec


edge length always clamped to multiple of 2R (!!)
radius always increase by 2R

networking strategy:
server updates
- send only dynamic fields (and all dynamic fields)
- send only nodes within viewport
- at certain zoom levels, stop showing bubbles (?)
- merge incoming gamestate
client updates
- all client changes create intermediate EVENTS which are processed at the beginning of the game update loop
- just serialize and send those to a server instance

optimizations like object pooling, delta compression, renderer clipping, etc postponed until deemed actually necessary

classes w/ constructors vs dumb duck-typed objects?

smart object pooling, where the actual bubble object is transferred to a holding pool inside nodes??
-and the pool size is clamped to the out-degree of the node
-wait until you actually see the GC graph looking like the rocky mountains before you implement this, its cool tho
-probably shouldnt be a problem on client side, since they will only render their local area
-if server memory performance becomes a problem implement this dope-ass smart object pooling
-that idea sounds cute but are you sure traditional object pooling isn't 100% better in every way? probably...
	-only advantage is not having to re-assign object fields every time... what is the savings here? minimal?
-maybe do both?

2hr planning

how to generate nodes...all distances must be multiple of some r
task: generate a set of points where all points are a whole number distance from their neighbors (any other points within set radius)

5/7/18
2hr procgen
1hr game logic

5/8
TODO
X some basic testing
/ node capture
X graphics: render nodes, edges, bubbles
- ui: stats panel?
- util: cycle through all players' bases?
- grow bases radius with bubblessss
	- tweak procgen
X network: send updates to clients
X network: handle new player connect
X network: receive client updates
X network: client receive server updates
- network: client send updates
X client command: build edge
X client command: delete edge
X client command: connect
- UI challenges with creating and deleting nodes.

0.75hr testing, bugfix, minor game logic feature
0.75hr graphics (untested)
2hr network base server and client

5/9

TODO
- Graphics: Test all rendering
- Graphics: Node capacity render
- Graphics: Color scheme
- UI: Create edge
- UI: Delete edge (????)
- UI: Node selected state (show radius, possible connections, owner name)
- UI: Color picker/name selector
- Game logic: Node radius growth
- Persistent login/database/auth
- Network optimization + testing
- Tutorial mode
- Hosting, site, deployment
- Automated backups, logging

2hrs brainstorming future ideas, because I didn't do any work at home

1.5hr @ home graphics rendering & edge drag

Graphics TODO:
- create edge
- delete edge
- indicate edge direction
- node select mode
- node text alignment
- source node highlight
- node radius growth

5/10

0.5hr easy edge drag fixes
1hr implement arrow drawing algorithm from scratch

pause and think

0.5hr implement arrow algorithm from stackoverflow

TODO

X remove edge (drag)
	X add a custom hitbox to all edges (on the arrowhead) using a polygon (or a circle worst-case)
		/ may need to copy code from drawArrow()
	X state where drag is initiated from an arrowhead
		X mousedown (edge starts following mouse, stop drawing old edge)
		X mouseup (remove old edge, maybe create new one)
X tweak drag edge preview
- convert edge creation and deletion to server-friendly commands
...
- color scheme
- arrow thickness, arrowhead size, node size, bubble size
X bubble radius growww
- text render

0.5hr implement edge drag to remove arrow
0.5hr improve edge drag preview

1
10
100
1000
10000
100000
1000000
10000000

0.5hr node potential edge mouseover

bug: bubbles remain when edge deleted (possible memory leak with graphics objects?)
bug: hitArea radius not updated when node radius is updated (possible fix untested)

TODO @ home:
- test with procgen world
- color scheme
- thickness & sizing

TODO @ work:
- stats util
	- how many sources do I own
	- how many nodes do I own
	- how many total bubbles
	- what's my biggest node
	- time node owned
	- percentage of all nodes owned
	- percentage of all bubbles owned
- offline report:
	- how many bubbles did I gain (count from all spawns)?
	- how many bubbles did I lose (count from all collisions with enemy bubbles/nodes)?
	- how many nodes did I gain?
	- how many nodes did I lose?

Stats:
- Nodes: 100 (10 source, generating a total of 100 bubbles per second)
- Bubbles: 3.9M - largest node: 100k (go there)

Offline Report:
- Bubbles gained -- Bubbles lost -- Net bubbles
- Nodes gained -- Nodes lost -- Net nodes
- Biggest competitor -- Bubbles spent -- Nodes captured (him, you, net)

0.5hr node radius + some planning

Leaderboards, obviously

Features with potential for expansion:
- Player profile view, with stats
- Graphs :D
- Offline mode report with MORE STATS
- Daily/weekly email report, with copy of above
- Server leaderboards, visible at all times like Agario
- Easy to split up into different servers, especially if there is a single winner every time
	- Global profile with "wins"
- Show who is logged in
- mobile version, obviously

game.clientCommands = []
-vs-
game.on("deleteEdge", client.sendDeleteEdgeMessage)

game.clientCommands = []
- renderer places the client command in there (or else game does it itself)
- client reaches in to grab these and sends them to server
- works as a message buffer which might be needed anyways?

game.on("event", ...)
- game.on (array of keys) will be sent from server?
	- but server will never use game.on...

big problem: edge deletions are just not registered (_.merge doesn't handle anything like this)
- do i need to write a custom merge thing? are there options I can set on _.merge?

1hr adding client commands -> server

remove edge problem notes:
-maybe (probably) Render should maintain its own list of sprites
-will need a Game.on("removeEdge") hook to clean up old ones
	-That's not enough, because "removeEdge" doesn't get called on a server gamestate merge
-so instead it needs to check everytime and do some manual garbage collection?
	-parallel data structure of node->edge->bubble to hold graphics objs

5/11

options to fix the edge removal bug
this bug applies to both graphics (view) and networking (controller)
it applies to *any* array where items are removed

Option 1: Pool everything
- Even though it may not be necessary for memory/gc performance, any "delete" operation is always a "dead=true" operation
- Downside: Bloat/memory creep (?)
	- Worst case scenario: Every edge that could exist, does exist, and is sent over the network

Option 2: observable triggers on almost every game operation
- Downside: A lot of reponsibility for the game object model who is supposed to be a dumb object
- Downside: Requires a different networking strategy, an object-wise merge wouldn't work anymore
	- you would need to write a custom merge algo that fires off lots of observable triggers

Option 3: parallel list of references in Render class which are manually kept in sync
- Downside: complex, kind of a hassle
- Upside: Game remains unchanged

5/12

some testing @ home

BUG: bubbles on edge when edge deleted
30 min @ home playtesting

5/14

TODO for alpha:
- determine world size (benchmark server update timing)
- finish tweaking procgen (max_edge, min_edge)
- optimize rendering
	- don't bother rendering stuff outside of vision
	- enforce a max zoom out distance
- join game ui (pick username and color)
- leave game -> return all nodes to server
- host backend
- pick name
- graphics style tweaks (esp. arrowhead z-index and size)
- kongregate release: '___ Alpha'
- ??? super simple tutorial?

TODO full release:
- domain name (if not already done in alpha)
- login + persistence
	- stats
	- reports
	- multiple servers?
- donations and/or ads
- some sort of community engagement board

NAME
"Abstract Open World Tower Defence Alpha"

Keywords:
nouns:
- node
- flow
- network
- graph
- digraph
- path
verbs:
- connect
- grow
- accumulate
- collect
connotations:
- online multiplayer
- competetive
- incremental/idle
- persistent

"Node Collector"
"Bubble Collector"
"BubbleScape"
"Nodescape" (or "NodeScape") *

"NodeScape Alpha"

1hr server load testing, planning, name brainstorming

"NodeStorm"
"NodeStorm Alpha"

"NodeStorm" vs "NodeScape"

1hr @home playtesting, bugfixing, balancing, performance investiagation

BUGS:
- destroy bubbles when edge removed
- source nodes growing/gaining capacity...
- not showing edge preview when a dead edge is there
- radius can grow too big, nodes eclipse eachother
- (minor) edge can snap to node which is too far?
- light colors will make text unreadable
- (minor) text not perfectly centered
- abbreviate long text

Optimization: X store all nodes as circles, then only re-draw if necessary
X store text separately and update?

For good performance:
- need to use sprites instead of graphics :/
- don't change text every frame
- cull objects off screen (?)
- .interactiveChildren=false if applicable
- .hitArea faster than no hit area specified

source: https://github.com/pixijs/pixi.js/wiki/v4-Performance-Tips

5/16:

Performance changes plan:
- Nodes and bubbles:
	- Determine minimum zoom level, and apparent radius of (largest possible) nodes (and bubbles) at that level
	- Draw a single white circle of the max radius
	- Scale to correct size for node or bubble (or just have a separate one for bubble)
	- Tint to the right color for node or bubble
	- Node text: Child object of the node sprite?? Font size set for max zoom level, like nodes
	- Check text before updating
	- Might need to use BitmapText
	- PROBLEM: antialiasing (might need scaled versions of sprites?)
		- Solved by graphics.generateCanvasTexture()
- Edges
	- Arrowhead: render a single white arrowhead of max size 
	- Tint, rotate, and scale as needed
	- Every arrowhead is its own sprite (and interactive)
	- Edges all rendered on a single graphics object (including edge preview)

1.5hr performance testing 

5/17:
0.5hr blind refactor (node sprite)
0.5hr blind refactor (edge sprite)
0.5hr blind refactor (drag preview, bubble, selected node)
0.5hr misc (arrowhead bugfix, planning)

5/18:

Potential network performance improvements:
- batch up client inputs and send on a timer
- send viewport rect to server
- server sends back only entities in rect + some padding
- server sends only certain properties
	- not full-on delta compression yet
- after certain zoom level, server stops sending bubbles (only nodes)
- don't simulate all 10k+ entities in client, only a few hundred
	- everything else, just wait for server to send it

Bare minimum gamestate:
{
	nodes: [
		{
			id,
			bubbles,
			owner
		},
		...
	],
	edges: [
		{
			from,
			to,
			dead
		},
		...
	],
	bubbles: [
		{
			edge: (from, to),
			owner,
			dead,
			pos
		},
		...
	],
	players:{
		username:color,
		...
	}
}

KEY
- = TODO
X = DONE
\ = IN PROGRESS
> = DELAY

TODO for alpha release:
- determine world size (benchmark server network timing)
\ bugfixes (see below)
> graphics optimization (if needed)
	X clip nodes outside viewport
	- bitmpatext
	- stop rendering bubbles at a certain zoom level (width)
> client optimization
	- client only updates nodes within viewport (custom update method)
		- abstract viewport clipping logic to a re-usable function
> network optimization (postpone until post-alpha??)
	- client sends viewport back
	- server sends only entities in viewport
	- batch and/or rate-limit client updates
- join game
	- client UI: name + color picker
	- client UI: quick GIF tutorial
	- server logic: reject duplicate usernames
		- client logic: handle username rejection
	- server logic: assign spawnpoint close to center
		- client logic: center viewport on assigned spawn
- leave game UI
	- client UI: pre-exit message
	- server logic: return all nodes to server
	- server logic: delete game.players[clientName]
- host backend
X pick name

BUGS:
X destroy bubbles when edge removed
X source nodes growing/gaining capacity...
X not showing edge preview when a dead edge is there
- radius can grow too big, nodes eclipse eachother
- (minor) edge can snap to node which is too far?
X light colors will make text unreadable
- (minor) text not perfectly centered (use TextMetrics.measureText?)
X abbreviate long text
X arrowhead rotating according to mouse pos rather than node center
X arrowhead not disappearing during dragMode from existing edge
- arrowhead a little too close to node (related to sprite anchor)
X arrowhead not snapping to node it already exists on (dragging existing edge)
X beginning to remove an edge but then cancelling kills all bubbles

0.5hr bugfixes
0.5hr render clipping

Future QOL ideas
- suicide/restart (without reloading page)
- locate/center viewport on own nodes
- stats
- re-show tutorial
- feedback
- donate

server connect protocol draft:
-client connects
-server sends full gamestate and starts sending updates
-client sends spawn request with username, color
-server validates and sends back either ID of assigned spawn OR reject msg

PROBLEM: sprite objects attached directly to game objects (will be serialized and sent :/)
- solution 1: custom serializer which strips out certain properties (builds separate obj for each client, each tick)
	- hurts memory on the server side a little bit; O(num_clients)
- solution 2: move sprites to a parallel list maintained in render class (maybe keyed by object? is this where WeakMap/WeakSet is used?)

5/22

1hr server-client protocol

BUG: can't make edges FIXED

BUG: client render loop may be out of sync with server loop (hitching every second)

TODO:
- client connect UI
- status UI (color, username, game name)
- spawn FAB
- @work: game.removePlayer, server handle player leave
- restart game FAB?
- client leave UI
- AWS instance
	- Docker?


1hr server disconnect, aws setup

5/23

1.5hr debugging aws websockets
1hr debugging aws websockets, implement self-signed ssl
1hr dns
1hr docker
1hr nginx

5/24

TODO
/ client join UI ("NodeScape Alpha" + name + color pick)
- node owner name on hover
	- canvas or DOM?
- top status bar with your username + color + name "NodeScape Alpha"
	- ?? button to hide bar
	- ?? dropdown menu with:
		- restart
		- locate
- ?? server highscores?
	- Nodes owned vs Bubbles owned
- leave game ui
- ?? server geo optimization
	- chunks
- ?? feedback widget
- Logo (font)
X Clamp max zoom, pan
X nodescape.io SSL cert
- client handle server disconnection (another timeout?)
- devops: configure node environments to easily switch between local server and remote server

Server optimization
- It is not necessary to send all entities to all players
- It is not efficient to build and serialize a separate gamestate for every player
- Break the data structure in the core game model into geometrically discrete chunks
	- Provide simple query returning which chunks correspond to a given query rect
- Each tick, all chunks are serialized (if needed; cached for 1 tick)
- Clients are sent only chunks that are relevant (an array of relevant chunks)
- Playerlist is sent separately
	- No geo optimization
- BUG: Render resources are still attached to game resources (?)
	- No, server renders nothing so nothing gets attached
- What is the optimal chunk size (and why?)
	- Half an avg screen size?
	- ~100 units? (10-20 nodes?)
- Before implementing full chunk data struct, maybe trying streaming individual nodes over ws?
	- Imitating a chunk size of n = 1
	- Cache the serialized nodes per tick
	- Instead of one monolithic gamestate you get 100+ mini streaming updates
	- Only question is the ws overhead

2hr ssl

Server optimization
- Client sends their viewport rect to server every second
	- this also functions as a ping, and a timeout can check for expired clients and remove them
- every second, server serializes *individual nodes* and caches them
	- for each client, for each node: checks if node is in viewport, and if so sends the serialized copy over ws
	- also checks the timestamp of last ack (viewport update) and times out dead clients

0.5hr netcode optimization

0.5hr @home graphics tweaks

BUG: player spawns not randomized (array length always === 1)
- hold up maybe its fine actually...
- but wait they seem too spread...

BUG: source nodes *still* growing

BUG: can pick white as a color (enforce maximum brightness)

BUG: also zoom in on spawn select

BUG: consistent jitter

BUG: spawns are way too separated

BUG: nodes are too far apart on avg

probably need a restart button

FEATURE: autoscrolling (and zooming?) camera pre-join? or focus on any content already there?

FEATURE: LOD to fix the gross antialiasing?

MINOR FEATURE: client-side inject the right color into the spawn before the server update comes

MINOR BUG: enter does not submit game start form (add onsubmit())

MINOR FEATURE: clicking non-owned nodes does not drag the viewport (? below a certain zoom lvl?)

BUG: nodes still eclipse

0.5hr @home pregame UI

5/25

TODOlist (compiled from yesterday's notes)
X player spawns not randomized (array length always === 1)
	- hold up maybe its fine actually...
	- but wait they seem too spread...
/ source nodes *still* growing
/ can pick white as a color (enforce maximum brightness)
- also zoom in on spawn select
- fix consistent jitter
- nodes are too far apart on avg
- probably need a restart button
- probably need a "find me" button
> autoscrolling (and zooming?) camera pre-join? or focus on any content already there?
> LOD to fix the gross antialiasing?
> client-side inject the right color into the spawn before the server update comes
X enter does not submit game start form (add onsubmit())
> clicking non-owned nodes should not drag the viewport (? below a certain zoom lvl?)
- nodes still eclipse
/ network optimization (send only nodes in viewport, > 90% bandwidth savings)
- endgame ui
X refactor ui to ui.js
X show node owner on hover
X Google fonts
/ callback handlers for username taken, etc
- ui handlers for server disconnect
X disable text selection on modal
> devops: configure node environments to easily switch between local server and remote server
X color picker
X color scheme for UI/modal
> sexy third party modal?
> sexy third party toasts?
> minimize spawn modal to FAB
> 'locate me' google maps-style FAB

0.5hr netcode optimization
0.5hr UI
0.35hr game.getSpawn() bugfix
0.15hr color validation

5/26

0.16hr @home color picker
0.25hr @home font
0.5hr @home buttons & pre-game ui
0.3hr @home node owner render

ALPHA TODO
- Tutorial (?)
- Procgen tweaks
	- Less disconnected subgraphs
	- Don't worry about edge lengths being integers?
	- Try to avoid eclipses

ALPHA or BETA?
- "find me" button
- "restart" button
- pixellation on zoom-in
	- quickfix: lock zoom in to good lvl
- on zoomout, stop rendering bubbles and increase edge radius
- pre-spawn viewport animation/zoom

BETA TODO
- zoom out nodes before spawn
- animate zoom in on spawn node
- animate viewport pre-spawn
- better random color selection
	- https://www.npmjs.com/package/randomcolor
- enforce non-greyscale colors
- bright colors still fucked
- node environments (dev vs prod)
- fix config
	- zoom lvl where things disappear
- show dotted circle of possible edge radius around a node?
- node radius increases edge radius?
- endgame ui
- BUG: only text has hitbox??
- BUG: when zoomed out, some edges disappear and some bubbles don't move?? 
- BUG: some arrowheads cant be grabbed

Tutorial
- Gif 1:
	- "Click and drag from a node you own to create an edge."
- Gif 2:
	- "Bubbles travel along edges to capture other nodes."
- Gif 3:
	- "Source nodes generate new bubbles on every edge."
- Gif 4:
	- "Drag an edge's arrowhead to remove it."
- Gif 4:
	- "Capture enemy nodes with your bubbles!"

1.5hr @home tutorial gifs

5/27

0.16hr @home flickity!


TODO
X fix jitter?
X fix eclipse?
	- nodes radius grow smaller increments (0.5?)
X dont render bubbles when zoomed out
	- edge radius++ (only when zoomed out, or all the time?)
X animate viewport pregame

TODO sometime?
X center number
X font resolution (easy?)
X make source nodes stand out more
	- border
	- black bg
X LOD (antialiasing at small zooms)
X stop edges at node edges
/ stop arrowheads at right spot
X leave behind a ghost edge when dragging an existing edge away
X Player name color in spawn form matches color picker
X Animate zoom and pan to spawn location (!)
X Ambient animation before spawn
> Sometimes bubbles immediately bounce on an empty node, sometimes they stay for 1 tick (update loop sync)
X Ease radius changes
X Watermark logo
X Animate modal

1hr @home playtest, bugfix, balance
2hr @home polish
1hr @home being braindead, looking for an option in the viewport API

5/28

2hr @home polish

FUTURE WORK
- hover node = enlarge arrowheads for easy clicking
- BUG: sometimes color picker starts at FFFFFF
	- Probably cuz color picker initializes late
- more pixel-perfect bubble collision (?)
- !! randomize or *cycle* which edge node take
- hover edge highlights node it's attached to??
- favicon
- remove non-responsive clients after timeout
- BUG: gifs sometimes don't load (on webserver)
- "Are you sure you want to leave?"
- Procgen only generates nodes on an integer grid...why?
- get zoom to start at the right lvl instead of flashing the zoomed-in version and then snapping
- minor visual bug during radius easing
- dragmode edges should be thick like normal edges
- BUG: source nodes aren't captured automatically (do they STILL have capacity?)
- a ghost client bubble is spawned before the real server bubble on newly captured bubbles
- client reconnect
- server detect disconnect

IDEAS
- little speech bubbles you can spawn in space?? (dark souls-style)
- URL which centers screen on certain place
- should all edges be unidirectional? kind of like settlers of catan?
- cumulative node value = global currency
- 3rd zoom out lvl showing polygons, or more likely *only edges*

TOP feedback
- arrowheads impossibly hard to remove
- multiple edges should cycle spawns
- warning prompt before exit

5/28 11:12 AM alpha 0.1.0 release !!!!!

Alpha 0.1.1 TODO
- arrowheads easier to click
- multiple edges cycle
- warning prompt before exit
- tutorial gif preload
-----
- patchnotes (cookie?)
5/28 11:12 AM alpha 0.1.0 release !!!!!

==== 45.38 total hours from scratch to alpha ====

6/14

METAGAME
- Gameplay upgrades
	- Per-node (purchased) or global (unlocked)
	- Examples
		- Bubble spawn rate
		- Edge radius
	- Potentially damages the minimalism/core vision
- Leaderboard
	- Not that compelling for most players
	- Not a good driver of premium purchases
	- COMPLEMENTARY to core vision (territory expansion)
- XP/Level system (xp = total bubbles across all nodes)
- Cosmetics
	- Node/bubble shape, pattern, skin
	- Damages the minimalism/core vision
- Prestige/roguelike?
	- Requires persistent user account ever for free users
- TF2/RL item drops + economy
	- Wtf do items do?
- Cookie clicker numerical incremental
	- Bubble form the base/lowest layer of the incremental
- Achievements
	- Requires persistent user account
	

METAGAME REQUIREMENTS
- Must be COMPLEMENTARY to core vision
	- Territory expansion
	- Simple minimalist mechanics
	- Intuitive gameplay
		- No complex upgrade/buff/level system
- Goals should be visibile, compelling, tantalizing
- Pacing: appropriate so some quick early unlocks introduce players
	to the upgrade system, while others would take days to unlock

IDEAS
- Show x/y coordinates in status bar, for navigation and communication purposes?
- Allow linking to certain x/y?
	- But how does this work with a pre-existing window? Won't it kill your nodes to load the new page?
