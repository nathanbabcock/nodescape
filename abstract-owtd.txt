5/3:
abstract-owtd
1hr planning

players = {
	"excalo": {
		color: "red"
	}
}

nodes = [
	// static
	id: id,
	x: x,
	y: y,

	// dynamic
	owner: "excalo",
	bubbles: 100,
	edges: [
		{
            to: id,
            bubbles: [
                owner: "asdf",
                pos: x,
                dead: false
            ]
        }
	]
]

//bubbles = [
//	//dynamic
//	owner: "excalo",
//	edge: {from: id, to: id}
//	dist: 135
//]

forEachBubble = players.forEach(player=>player.bases.forEach(base=>))

get edges from node: O(1)
get edges to node: O(V)
get nodes in a given area: O(V) -- or better quadtree
get all nodes of a player: O(V)
get all players in an area (by nodes): see above
get bubbles on a given edge: get specific edge O(1) + get bubbles on edge O(bubbles)

bubble update loop: O(B)
1. check for on-edge collisions
	is there an opposing edge? O(1)
	is there a bubble on that edge? O(1)
	what will this bubble's new position be?
	for each bubble
		what will their new position be?
		did this delta t overlap the original delta t?
			kill both
2. check for node collisions (kill bubble, either add or subtract from node)
3. move bubbles
	use the values computed from step 1 above, now that colliding bubbles have been removed
4. spawn new bubbles? (when?)

1000 players
1000 players * 100 nodes each
1000 players * 100 nodes each * 3 edges per node
1000 players * 100 nodes each * 3 edges per node * 5 bubbles per edge
1000 * 100 * 3 * 5 = 1.5M
O(1.5M^2) bubble update

how many 'live' bubbles (on edges) does a player have?
nodes.map(node=>node.edges).map(edge=>edge.bubbles).length (or something like that, maybe with a mapreduce instead)

algorithmic complexity ✓
object pooling ✓
delta compression ✓
ease-of-use ✓

main algorith challenges to define:
- server side bubble update loop
	- collision detection
	- how node radius effects node-bubble collision
- client side bubble update loop (with collision detection)


optimizations to postpone:
- delta compression
- spatial data structures
- cacheing/memoization

5/4: more specific planning for abstract-owtd

bubble update loop: O(B)
1. pre-move, and on-edge collision checking
	calculate and cache this bubbles future position
	is there an opposing edge? O(1)
		is there a bubble on that edge? O(1)
			for each bubble
				calculate and cache this bubbles future position
				did this delta overlap the original delta?
					kill both
2. check for node collisions (kill bubble, either add or subtract from node)
3. move bubbles
	use the values computed from step 1 above, now that colliding bubbles have been removed
4. spawn new bubbles? (when?)
	move to outside of spawning node radius
	check for collision on spawn?

client side bubble render:
- get delta time since last real update
- interpolate bubble position
- check collisions of all kinds

collisions always happen between furthest nodes on opposing edges

enforce a grid by:
all edge distances are in increments according to the move speed of bubbles
- if a bubble moves 10px/sec, edges are always divisible by 10
- radii increase/decrease in increments of 10 only

ALL collisions now only happen exactly during game loop ticks...woah sick
just interpolate the position and you're good to go
wait no

given bubble radius r
every tick, bubble move by r
every 4 ticks (or more, must be even), bubbles spawn
4 ticks per second
bubble move speed = 4r/sec


edge length always clamped to multiple of 2R (!!)
radius always increase by 2R

networking strategy:
server updates
- send only dynamic fields (and all dynamic fields)
- send only nodes within viewport
- at certain zoom levels, stop showing bubbles (?)
- merge incoming gamestate
client updates
- all client changes create intermediate EVENTS which are processed at the beginning of the game update loop
- just serialize and send those to a server instance

optimizations like object pooling, delta compression, renderer clipping, etc postponed until deemed actually necessary

classes w/ constructors vs dumb duck-typed objects?

smart object pooling, where the actual bubble object is transferred to a holding pool inside nodes??
-and the pool size is clamped to the out-degree of the node
-wait until you actually see the GC graph looking like the rocky mountains before you implement this, its cool tho
-probably shouldnt be a problem on client side, since they will only render their local area
-if server memory performance becomes a problem implement this dope-ass smart object pooling
-that idea sounds cute but are you sure traditional object pooling isn't 100% better in every way? probably...
	-only advantage is not having to re-assign object fields every time... what is the savings here? minimal?
-maybe do both?

2hr planning

how to generate nodes...all distances must be multiple of some r
task: generate a set of points where all points are a whole number distance from their neighbors (any other points within set radius)

5/7/18
2hr procgen
1hr game logic

5/8
TODO
X some basic testing
/ node capture
X graphics: render nodes, edges, bubbles
- ui: stats panel?
- util: cycle through all players' bases?
- grow bases radius with bubblessss
	- tweak procgen
X network: send updates to clients
X network: handle new player connect
X network: receive client updates
X network: client receive server updates
- network: client send updates
X client command: build edge
X client command: delete edge
X client command: connect
- UI challenges with creating and deleting nodes.

0.75hr testing, bugfix, minor game logic feature
0.75hr graphics (untested)
2hr network base server and client

5/9

TODO
- Graphics: Test all rendering
- Graphics: Node capacity render
- Graphics: Color scheme
- UI: Create edge
- UI: Delete edge (????)
- UI: Node selected state (show radius, possible connections, owner name)
- UI: Color picker/name selector
- Game logic: Node radius growth
- Persistent login/database/auth
- Network optimization + testing
- Tutorial mode
- Hosting, site, deployment
- Automated backups, logging

2hrs brainstorming future ideas, because I didn't do any work at home

1.5hr @ home graphics rendering & edge drag

Graphics TODO:
- create edge
- delete edge
- indicate edge direction
- node select mode
- node text alignment
- source node highlight
- node radius growth

5/10

0.5hr easy edge drag fixes
1hr implement arrow drawing algorithm from scratch

pause and think

0.5hr implement arrow algorithm from stackoverflow

TODO

X remove edge (drag)
	X add a custom hitbox to all edges (on the arrowhead) using a polygon (or a circle worst-case)
		/ may need to copy code from drawArrow()
	X state where drag is initiated from an arrowhead
		X mousedown (edge starts following mouse, stop drawing old edge)
		X mouseup (remove old edge, maybe create new one)
X tweak drag edge preview
- convert edge creation and deletion to server-friendly commands
...
- color scheme
- arrow thickness, arrowhead size, node size, bubble size
X bubble radius growww
- text render

0.5hr implement edge drag to remove arrow
0.5hr improve edge drag preview

1
10
100
1000
10000
100000
1000000
10000000

0.5hr node potential edge mouseover

bug: bubbles remain when edge deleted (possible memory leak with graphics objects?)
bug: hitArea radius not updated when node radius is updated (possible fix untested)

TODO @ home:
- test with procgen world
- color scheme
- thickness & sizing

TODO @ work:
- stats util
	- how many sources do I own
	- how many nodes do I own
	- how many total bubbles
	- what's my biggest node
	- time node owned
	- percentage of all nodes owned
	- percentage of all bubbles owned
- offline report:
	- how many bubbles did I gain (count from all spawns)?
	- how many bubbles did I lose (count from all collisions with enemy bubbles/nodes)?
	- how many nodes did I gain?
	- how many nodes did I lose?

Stats:
- Nodes: 100 (10 source, generating a total of 100 bubbles per second)
- Bubbles: 3.9M - largest node: 100k (go there)

Offline Report:
- Bubbles gained -- Bubbles lost -- Net bubbles
- Nodes gained -- Nodes lost -- Net nodes
- Biggest competitor -- Bubbles spent -- Nodes captured (him, you, net)

0.5hr node radius + some planning

Leaderboards, obviously

Features with potential for expansion:
- Player profile view, with stats
- Graphs :D
- Offline mode report with MORE STATS
- Daily/weekly email report, with copy of above
- Server leaderboards, visible at all times like Agario
- Easy to split up into different servers, especially if there is a single winner every time
	- Global profile with "wins"
- Show who is logged in
- mobile version, obviously

game.clientCommands = []
-vs-
game.on("deleteEdge", client.sendDeleteEdgeMessage)

game.clientCommands = []
- renderer places the client command in there (or else game does it itself)
- client reaches in to grab these and sends them to server
- works as a message buffer which might be needed anyways?

game.on("event", ...)
- game.on (array of keys) will be sent from server?
	- but server will never use game.on...

big problem: edge deletions are just not registered (_.merge doesn't handle anything like this)
- do i need to write a custom merge thing? are there options I can set on _.merge?

1hr adding client commands -> server

remove edge problem notes:
-maybe (probably) Render should maintain its own list of sprites
-will need a Game.on("removeEdge") hook to clean up old ones
	-That's not enough, because "removeEdge" doesn't get called on a server gamestate merge
-so instead it needs to check everytime and do some manual garbage collection?
	-parallel data structure of node->edge->bubble to hold graphics objs

5/11

options to fix the edge removal bug
this bug applies to both graphics (view) and networking (controller)
it applies to *any* array where items are removed

Option 1: Pool everything
- Even though it may not be necessary for memory/gc performance, any "delete" operation is always a "dead=true" operation
- Downside: Bloat/memory creep (?)
	- Worst case scenario: Every edge that could exist, does exist, and is sent over the network

Option 2: observable triggers on almost every game operation
- Downside: A lot of reponsibility for the game object model who is supposed to be a dumb object
- Downside: Requires a different networking strategy, an object-wise merge wouldn't work anymore
	- you would need to write a custom merge algo that fires off lots of observable triggers

Option 3: parallel list of references in Render class which are manually kept in sync
- Downside: complex, kind of a hassle
- Upside: Game remains unchanged

5/12

some testing @ home

BUG: bubbles on edge when edge deleted
30 min @ home playtesting

5/14

TODO for alpha:
- determine world size (benchmark server update timing)
- finish tweaking procgen (max_edge, min_edge)
- optimize rendering
	- don't bother rendering stuff outside of vision
	- enforce a max zoom out distance
- join game ui (pick username and color)
- leave game -> return all nodes to server
- host backend
- pick name
- graphics style tweaks (esp. arrowhead z-index and size)
- kongregate release: '___ Alpha'
- ??? super simple tutorial?

TODO full release:
- domain name (if not already done in alpha)
- login + persistence
	- stats
	- reports
	- multiple servers?
- donations and/or ads
- some sort of community engagement board

NAME
"Abstract Open World Tower Defence Alpha"

Keywords:
nouns:
- node
- flow
- network
- graph
- digraph
- path
verbs:
- connect
- grow
- accumulate
- collect
connotations:
- online multiplayer
- competetive
- incremental/idle
- persistent

"Node Collector"
"Bubble Collector"
"BubbleScape"
"Nodescape" (or "NodeScape") *

"NodeScape Alpha"

1hr server load testing, planning, name brainstorming

"NodeStorm"
"NodeStorm Alpha"

"NodeStorm" vs "NodeScape"

1hr @home playtesting, bugfixing, balancing, performance investiagation

BUGS:
- destroy bubbles when edge removed
- source nodes growing/gaining capacity...
- not showing edge preview when a dead edge is there
- radius can grow too big, nodes eclipse eachother
- (minor) edge can snap to node which is too far?
- light colors will make text unreadable
- (minor) text not perfectly centered
- abbreviate long text

Optimization: X store all nodes as circles, then only re-draw if necessary
X store text separately and update?

For good performance:
- need to use sprites instead of graphics :/
- don't change text every frame
- cull objects off screen (?)
- .interactiveChildren=false if applicable
- .hitArea faster than no hit area specified

source: https://github.com/pixijs/pixi.js/wiki/v4-Performance-Tips

5/16:

Performance changes plan:
- Nodes and bubbles:
	- Determine minimum zoom level, and apparent radius of (largest possible) nodes (and bubbles) at that level
	- Draw a single white circle of the max radius
	- Scale to correct size for node or bubble (or just have a separate one for bubble)
	- Tint to the right color for node or bubble
	- Node text: Child object of the node sprite?? Font size set for max zoom level, like nodes
	- Check text before updating
	- Might need to use BitmapText
	- PROBLEM: antialiasing (might need scaled versions of sprites?)
		- Solved by graphics.generateCanvasTexture()
- Edges
	- Arrowhead: render a single white arrowhead of max size 
	- Tint, rotate, and scale as needed
	- Every arrowhead is its own sprite (and interactive)
	- Edges all rendered on a single graphics object (including edge preview)

1.5hr performance testing 

5/17:
0.5hr blind refactor (node sprite)
0.5hr blind refactor (edge sprite)
0.5hr blind refactor (drag preview, bubble, selected node)
0.5hr misc (arrowhead bugfix, planning)

5/18:

Potential network performance improvements:
- batch up client inputs and send on a timer
- send viewport rect to server
- server sends back only entities in rect + some padding
- server sends only certain properties
	- not full-on delta compression yet
- after certain zoom level, server stops sending bubbles (only nodes)
- don't simulate all 10k+ entities in client, only a few hundred
	- everything else, just wait for server to send it

Bare minimum gamestate:
{
	nodes: [
		{
			id,
			bubbles,
			owner
		},
		...
	],
	edges: [
		{
			from,
			to,
			dead
		},
		...
	],
	bubbles: [
		{
			edge: (from, to),
			owner,
			dead,
			pos
		},
		...
	],
	players:{
		username:color,
		...
	}
}

KEY
- = TODO
X = DONE
\ = IN PROGRESS
> = DELAY

TODO for alpha release:
- determine world size (benchmark server network timing)
\ bugfixes (see below)
> graphics optimization (if needed)
	X clip nodes outside viewport
	- bitmpatext
	- stop rendering bubbles at a certain zoom level (width)
> client optimization
	- client only updates nodes within viewport (custom update method)
		- abstract viewport clipping logic to a re-usable function
> network optimization (postpone until post-alpha??)
	- client sends viewport back
	- server sends only entities in viewport
	- batch and/or rate-limit client updates
- join game
	- client UI: name + color picker
	- client UI: quick GIF tutorial
	- server logic: reject duplicate usernames
		- client logic: handle username rejection
	- server logic: assign spawnpoint close to center
		- client logic: center viewport on assigned spawn
- leave game UI
	- client UI: pre-exit message
	- server logic: return all nodes to server
	- server logic: delete game.players[clientName]
- host backend
X pick name

BUGS:
X destroy bubbles when edge removed
X source nodes growing/gaining capacity...
X not showing edge preview when a dead edge is there
- radius can grow too big, nodes eclipse eachother
- (minor) edge can snap to node which is too far?
X light colors will make text unreadable
- (minor) text not perfectly centered (use TextMetrics.measureText?)
X abbreviate long text
X arrowhead rotating according to mouse pos rather than node center
X arrowhead not disappearing during dragMode from existing edge
- arrowhead a little too close to node (related to sprite anchor)
X arrowhead not snapping to node it already exists on (dragging existing edge)
X beginning to remove an edge but then cancelling kills all bubbles

0.5hr bugfixes
0.5hr render clipping

Future QOL ideas
- suicide/restart (without reloading page)
- locate/center viewport on own nodes
- stats
- re-show tutorial
- feedback
- donate

server connect protocol draft:
-client connects
-server sends full gamestate and starts sending updates
-client sends spawn request with username, color
-server validates and sends back either ID of assigned spawn OR reject msg

PROBLEM: sprite objects attached directly to game objects (will be serialized and sent :/)
- solution 1: custom serializer which strips out certain properties (builds separate obj for each client, each tick)
	- hurts memory on the server side a little bit; O(num_clients)
- solution 2: move sprites to a parallel list maintained in render class (maybe keyed by object? is this where WeakMap/WeakSet is used?)
